# Final CQI Score Formula Design for Harmonia

**Version:** 2.0 (Simplified)  
**Date:** January 22, 2026  
**Author:** Technical Architecture Team

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Commit Filter Module](#2-commit-filter-module) â¬…ï¸ **NEW: Pre-Processing**
3. [CQI Components](#3-cqi-components)
4. [Edge Cases](#4-edge-cases)
5. [Validation Scenarios](#5-validation-scenarios)
6. [Implementation Guide](#6-implementation-guide)

---

## 1. Executive Summary

### 1.1 CQI Formula

$$
\boxed{\text{CQI} = \text{BASE\_SCORE} \times \text{PENALTY\_MULTIPLIER}}
$$

Where:
$$
\text{BASE\_SCORE} = 0.40 \cdot S_{\text{effort}} + 0.25 \cdot S_{\text{loc}} + 0.20 \cdot S_{\text{temporal}} + 0.15 \cdot S_{\text{ownership}}
$$

| Component | Weight | What it measures |
|-----------|--------|------------------|
| **Effort Balance** | 40% | LLM-weighted effort distribution (quality-aware) |
| **LoC Balance** | 25% | Raw lines of code distribution |
| **Temporal Spread** | 20% | Work spread over project duration |
| **Ownership Spread** | 15% | Files shared among team members |

### 1.2 Penalty Multipliers

| Condition | Threshold | Multiplier |
|-----------|-----------|------------|
| Solo Development | >85% effort | Ã—0.25 |
| Severe Imbalance | >70% effort | Ã—0.70 |
| High Trivial Ratio | >50% trivial | Ã—0.85 |
| Low LLM Confidence | >40% low conf | Ã—0.90 |
| Late Work | >50% in final 20% | Ã—0.85 |

### 1.3 Key Insight: Filter First, Then Score

Instead of complex penalty multipliers, we **filter out non-productive commits BEFORE scoring**:

```
Raw Commits â†’ [Commit Filter] â†’ Productive Commits â†’ [CQI Calculator] â†’ Score
```

This keeps the CQI formula simple while still handling:
- Trivial commits (typos, formatting)
- Auto-generated code
- Copy-pasted content
- Empty/merge commits

### 1.4 Quick Examples

| Team | Description | CQI |
|------|-------------|-----|
| Perfect | 50/50 split, consistent work | **95-100** |
| Good | 60/40 split, some late work | **75-85** |
| Acceptable | 70/30 split | **60-70** |
| Poor | 85/15 split | **30-45** |
| Solo | 95/5 split | **10-20** |

---

## 2. Commit Filter Module

### 2.1 Purpose

**Pre-filter commits that don't represent real work** before calculating CQI.

This is a **separate module** that runs before the CQI calculation, not part of the formula itself.

### 2.2 Filter Categories

| Category | Detection Method | Action |
|----------|-----------------|--------|
| **TRIVIAL** | LLM classification = TRIVIAL | Exclude from effort sum |
| **AUTO_GENERATED** | Pattern detection + LLM novelty < 3 | Exclude completely |
| **COPY_PASTE** | LLM novelty < 2 + high LoC | Reduce weight to 10% |
| **EMPTY** | 0 lines changed | Exclude completely |
| **MERGE** | Commit message starts with "Merge" | Exclude completely |

### 2.3 Detection Rules

#### 2.3.1 Auto-Generated Code Detection

```java
boolean isAutoGenerated(CommitChunkDTO chunk, EffortRatingDTO rating) {
    // Rule 1: LLM says low novelty + low effort
    if (rating.novelty() < 3 && rating.effortScore() < 2) {
        return true;
    }
    
    // Rule 2: Known generated file patterns
    List<String> generatedPatterns = List.of(
        "package-lock.json",
        "yarn.lock", 
        "*.min.js",
        "*.min.css",
        "*.generated.*",
        "node_modules/",
        "build/",
        "dist/"
    );
    
    return chunk.files().stream()
        .anyMatch(f -> generatedPatterns.stream()
            .anyMatch(p -> matchesPattern(f, p)));
}
```

#### 2.3.2 Copy-Paste Detection

```java
boolean isCopyPaste(CommitChunkDTO chunk, EffortRatingDTO rating) {
    // High LoC but very low novelty = likely copy-paste
    return chunk.totalLinesChanged() > 100 
        && rating.novelty() < 2
        && rating.complexity() < 3;
}
```

#### 2.3.3 Trivial Commit Detection

Already handled by LLM classification (`CommitLabel.TRIVIAL`), but add backup rules:

```java
boolean isTrivial(CommitChunkDTO chunk, EffortRatingDTO rating) {
    // LLM says trivial
    if (rating.type() == CommitLabel.TRIVIAL) {
        return true;
    }
    
    // Backup: very small change with low effort
    return chunk.totalLinesChanged() < 5 
        && rating.effortScore() < 2;
}
```

### 2.4 Filter Output

```java
public record FilteredCommitsDTO(
    List<CommitChunkDTO> productiveCommits,  // Used for CQI
    List<CommitChunkDTO> filteredOut,        // For transparency
    FilterSummary summary
) {}

public record FilterSummary(
    int totalCommits,
    int productiveCommits,
    int trivialCount,
    int autoGeneratedCount,
    int copyPasteCount,
    int emptyCount,
    int mergeCount
) {}
```

### 2.5 Implementation: CommitFilterService

```java
@Service
@Slf4j
public class CommitFilterService {

    public FilteredCommitsDTO filterCommits(List<RatedChunk> ratedChunks) {
        List<CommitChunkDTO> productive = new ArrayList<>();
        List<CommitChunkDTO> filtered = new ArrayList<>();
        
        int trivial = 0, autoGen = 0, copyPaste = 0, empty = 0, merge = 0;
        
        for (RatedChunk rc : ratedChunks) {
            CommitChunkDTO chunk = rc.chunk();
            EffortRatingDTO rating = rc.rating();
            
            // Check filters in order
            if (isEmpty(chunk)) {
                empty++;
                filtered.add(chunk);
            } else if (isMergeCommit(chunk)) {
                merge++;
                filtered.add(chunk);
            } else if (isAutoGenerated(chunk, rating)) {
                autoGen++;
                filtered.add(chunk);
            } else if (isCopyPaste(chunk, rating)) {
                copyPaste++;
                // Don't exclude, but mark for reduced weight
                chunk = chunk.withReducedWeight(0.1);
                productive.add(chunk);
            } else if (isTrivial(chunk, rating)) {
                trivial++;
                filtered.add(chunk);
            } else {
                productive.add(chunk);
            }
        }
        
        log.info("Filtered {}/{} commits: {} trivial, {} auto-gen, {} copy-paste, {} empty, {} merge",
            filtered.size(), ratedChunks.size(), trivial, autoGen, copyPaste, empty, merge);
        
        return new FilteredCommitsDTO(
            productive, 
            filtered,
            new FilterSummary(ratedChunks.size(), productive.size(), 
                             trivial, autoGen, copyPaste, empty, merge)
        );
    }
    
    private boolean isEmpty(CommitChunkDTO chunk) {
        return chunk.totalLinesChanged() == 0;
    }
    
    private boolean isMergeCommit(CommitChunkDTO chunk) {
        String msg = chunk.commitMessage();
        return msg != null && (
            msg.startsWith("Merge ") || 
            msg.startsWith("Merge pull request")
        );
    }
    
    // ... other detection methods as above
}
```

---

## 3. CQI Components

### 3.1 Effort Balance Score ($S_{\text{effort}}$) â€” Weight: 40%

**Input:** Filtered commits with LLM effort ratings

**Formula:**

$$
S_{\text{effort}} = 100 \times (1 - \text{Gini}(E))
$$

Where $E = [e_1, e_2, ..., e_n]$ = weighted effort per author.

**Gini Coefficient:**

$$
\text{Gini}(E) = \frac{\sum_i \sum_j |e_i - e_j|}{2n \sum_i e_i}
$$

| Distribution | Gini | Score |
|--------------|------|-------|
| 50/50 | 0.00 | 100 |
| 60/40 | 0.10 | 90 |
| 70/30 | 0.20 | 80 |
| 80/20 | 0.30 | 70 |
| 90/10 | 0.40 | 60 |
| 100/0 | 0.50 | 50 |

**Implementation:**

```java
public double calculateEffortBalance(Map<Long, Double> effortByAuthor) {
    if (effortByAuthor.size() <= 1) return 0.0;
    
    double[] efforts = effortByAuthor.values().stream()
        .mapToDouble(Double::doubleValue).toArray();
    
    return 100.0 * (1.0 - gini(efforts));
}

private double gini(double[] values) {
    int n = values.length;
    double sum = Arrays.stream(values).sum();
    if (sum == 0) return 1.0;
    
    double diffSum = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            diffSum += Math.abs(values[i] - values[j]);
        }
    }
    return diffSum / (2.0 * n * sum);
}
```

---

### 3.2 LoC Balance Score ($S_{\text{loc}}$) â€” Weight: 25%

**Input:** Lines added + deleted per author (from filtered commits)

**Formula:**

$$
S_{\text{loc}} = 100 \times (1 - \text{Gini}(L))
$$

Where $L = [l_1, l_2, ..., l_n]$ = lines changed per author.

**Why keep LoC?**
- Provides fallback when LLM fails
- Simple, objective metric
- Catches cases where LLM over/underestimates

**Implementation:**

```java
public double calculateLocBalance(Map<Long, Integer> locByAuthor) {
    if (locByAuthor.size() <= 1) return 0.0;
    
    double[] locs = locByAuthor.values().stream()
        .mapToDouble(Integer::doubleValue).toArray();
    
    return 100.0 * (1.0 - gini(locs));
}
```

---

### 3.3 Temporal Spread Score ($S_{\text{temporal}}$) â€” Weight: 20%

**Input:** Commit timestamps from filtered chunks

**Purpose:** Rewards work spread evenly over project duration, penalizes cramming.

**Formula:**

$$
S_{\text{temporal}} = 100 \times (1 - \frac{\text{CV}_{\text{weekly}}}{2})
$$

Where CV = coefficient of variation of weekly effort distribution.

**Implementation:**

```java
private double calculateTemporalSpread(List<FilteredChunkDTO> chunks,
                                       LocalDateTime projectStart,
                                       LocalDateTime projectEnd) {
    // Divide project into weeks
    int numWeeks = Math.max(1, (int) Math.ceil(totalDays / 7.0));
    double[] weeklyEffort = new double[numWeeks];
    
    for (FilteredChunkDTO chunk : chunks) {
        int weekIndex = (int) (daysSinceStart / 7);
        weeklyEffort[weekIndex] += chunk.effectiveEffort();
    }
    
    // Calculate coefficient of variation
    double cv = stdev / mean;
    double normalizedCV = Math.min(cv / 2.0, 1.0);
    
    return 100.0 * (1.0 - normalizedCV);
}
```

---

### 3.4 Ownership Spread Score ($S_{\text{ownership}}$) â€” Weight: 15%

**Input:** File paths from filtered chunks

**Purpose:** Rewards multiple authors working on the same files.

**Formula:**

$$
S_{\text{ownership}} = 100 \times \frac{\sum_f \min(\text{authors}_f, 4)}{|\text{Files}| \times \min(n, 4)}
$$

**Implementation:**

```java
private double calculateOwnershipSpread(List<FilteredChunkDTO> chunks, int teamSize) {
    // Map: filename -> set of author IDs
    Map<String, Set<Long>> fileAuthors = new HashMap<>();
    
    for (FilteredChunkDTO chunk : chunks) {
        for (String file : chunk.files()) {
            fileAuthors.computeIfAbsent(file, k -> new HashSet<>())
                       .add(chunk.authorId());
        }
    }
    
    // Filter to significant files (>= 3 commits)
    // Calculate average author count per file
    int effectiveTeamSize = Math.min(teamSize, 4);
    double totalAuthors = significantFiles.stream()
        .mapToDouble(f -> Math.min(fileAuthors.get(f).size(), effectiveTeamSize))
        .sum();
    
    return 100.0 * totalAuthors / (significantFiles.size() * effectiveTeamSize);
}
```

---

### 3.5 Combined CQI

```java
public CQIResultDTO calculate(CQIInputDTO input) {
    // Calculate component scores
    double effortScore = calculateEffortBalance(input.effortByAuthor());
    double locScore = calculateLocBalance(input.locByAuthor());
    double temporalScore = calculateTemporalSpread(chunks, start, end);
    double ownershipScore = calculateOwnershipSpread(chunks, teamSize);
    
    // Weighted sum
    double baseScore = 0.40 * effortScore 
                     + 0.25 * locScore 
                     + 0.20 * temporalScore 
                     + 0.15 * ownershipScore;
    
    // Apply penalties
    List<CQIPenaltyDTO> penalties = calculatePenalties(input);
    double penaltyMultiplier = penalties.stream()
        .mapToDouble(CQIPenaltyDTO::multiplier)
        .reduce(1.0, (a, b) -> a * b);
    
    return new CQIResultDTO(baseScore * penaltyMultiplier, ...);
}
```

---

## 4. Edge Cases

| Case | Handling |
|------|----------|
| **Single contributor** | CQI = 0 |
| **All commits filtered** | CQI = 0, flag for review |
| **LLM fails completely** | Use 100% LoC weight |
| **No commits** | CQI = 0 |
| **2-person team** | Formula works naturally |

---

## 5. Validation Scenarios

### 5.1 Perfect Team (CQI: 100)

- 2 members, effort: 50%/50%, LoC: 50%/50%
- $S_E = 100$, $S_L = 100$
- **CQI = 0.6Ã—100 + 0.4Ã—100 = 100**

### 5.2 Good Team (CQI: 88)

- 2 members, effort: 55%/45%, LoC: 60%/40%
- $S_E = 95$, $S_L = 80$
- **CQI = 0.6Ã—95 + 0.4Ã—80 = 89**

### 5.3 Solo Development (CQI: 15)

- 2 members, effort: 95%/5%, LoC: 90%/10%
- $S_E = 10$, $S_L = 20$
- **CQI = 0.6Ã—10 + 0.4Ã—20 = 14**

### 5.4 Balanced but Lots of Trivial (CQI: 85)

- 2 members, 50/50 split
- But 40% commits were filtered as trivial
- Post-filter: still 50/50
- **CQI = 100** (filtering worked!)
- Dashboard shows: "40% trivial commits filtered"

### 5.5 Copy-Paste Heavy (CQI: ~60)

- Member A: 1000 LoC (but 800 copy-pasted â†’ weight reduced to 80 effective)
- Member B: 200 LoC (all original)
- Effective ratio: ~30%/70% after copy-paste weight reduction
- **CQI â‰ˆ 60**

---

## 6. Implementation Guide

### 6.1 File Structure

All CQI-related code is organized as follows:

```
src/main/java/de/tum/cit/aet/analysis/
â”œâ”€â”€ service/cqi/
â”‚   â”œâ”€â”€ CQICalculatorService.java    # Main calculation service
â”‚   â”œâ”€â”€ CommitFilterService.java     # Pre-processing filter
â”‚   â””â”€â”€ CQIConfig.java               # Configuration properties
â””â”€â”€ dto/cqi/
    â”œâ”€â”€ CQIInputDTO.java             # Input data
    â”œâ”€â”€ CQIResultDTO.java            # Result with breakdown
    â”œâ”€â”€ ComponentScoresDTO.java      # Component scores
    â”œâ”€â”€ CQIPenaltyDTO.java           # Penalty details
    â”œâ”€â”€ FilteredChunkDTO.java        # Filtered commit chunk
    â””â”€â”€ FilterSummaryDTO.java        # Filter statistics
```

**Benefits of this structure:**
- DTOs centralized in `/dto` folder (standard Java convention)
- CQI-specific DTOs in `/dto/cqi` subfolder
- Services in `/service/cqi` for easy discovery
- Clear separation of concerns

### 6.2 CQICalculatorService

See: [CQICalculatorService.java](src/main/java/de/tum/cit/aet/analysis/service/cqi/CQICalculatorService.java)

Main entry points:
- `calculate(CQIInputDTO)` - Calculate from pre-aggregated data
- `calculateFromRaw(List<RatedChunk>, ...)` - Full pipeline with filtering

### 6.3 CommitFilterService

See: [CommitFilterService.java](src/main/java/de/tum/cit/aet/analysis/service/cqi/CommitFilterService.java)

Filters:
- Empty commits (0 LoC)
- Merge commits  
- Auto-generated files (lock files, build outputs)
- Copy-paste (reduced weight to 10%)
- Trivial commits (LLM-classified or <5 LoC)

### 6.4 Configuration

See: [CQIConfig.java](src/main/java/de/tum/cit/aet/analysis/service/cqi/CQIConfig.java)

All weights, thresholds, and penalties are configurable via `application.yml`:

```yaml
harmonia:
  cqi:
    weights:
      effort: 0.40
      loc: 0.25
      temporal: 0.20
      ownership: 0.15
    thresholds:
      solo-development: 0.85
      severe-imbalance: 0.70
      high-trivial: 0.50
    penalties:
      solo-development: 0.25
      severe-imbalance: 0.70
      high-trivial: 0.85
```

### 6.5 Integration in RequestService

Replace current calculation:

```java
// OLD:
cqi = balanceCalculator.calculate(commitCounts);

// NEW:
@Autowired
private CQICalculatorService cqiCalculatorService;

// In saveSingleResult:
CQIResultDTO result = cqiCalculatorService.calculateFromRaw(
    ratedChunks, 
    students.size(),
    projectStart,
    projectEnd,
    avgConfidence,
    lowConfCount
);
cqi = result.cqi();
```

---

## Summary: What's Implemented

| Component | Status | File |
|-----------|--------|------|
| CQI Calculator | âœ… Implemented | `CQICalculatorService.java` |
| Commit Filter | âœ… Implemented | `CommitFilterService.java` |
| Configuration | âœ… Implemented | `CQIConfig.java` |
| DTOs | âœ… Implemented | `dto/*.java` |
| RequestService Integration | ðŸ”œ TODO | Connect to existing pipeline |

**Components:**
- 4 components: Effort (40%), LoC (25%), Temporal (20%), Ownership (15%)
- 5 penalties: Solo, Imbalance, Trivial, Confidence, Late Work
- Pre-filtering: Empty, Merge, Auto-gen, Copy-paste, Trivial

---

*End of Document*
